<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd">
	<!-- applicationContext : 컨테이너가 구동되는 시점에 <bean> 등록된 클래스들을 객체 생성하는 즉시 로딩 
		방식으로 동작 -->
		
		<!-- 컴포넌트 스캔 : 스프링 설정 파일에 애플리케이션에서 사용할 객체들을 <bean> 등록하지 않고 자동으로 생성 -->
		<!-- 스프링 컨테이너는 클래스 패스에 있는 클래스들을 스캔하여 @component가 설정된 클래스들을 자동으로 객체 생성 -->
<!-- 		<context:component-scan base-package="polymorphism"></context:component-scan>
		
		<bean class="polymorphism.SonySpeaker"></bean> -->
		
		<context:component-scan base-package="com.myspring.biz"></context:component-scan>
		
<!-- 		<bean id="log" class="com.myspring.biz.common.LogAdvice"></bean>
		<bean id="log" class="com.myspring.biz.common.Log4jAdvice"></bean>
		<aop:config>
		<aop:config> : 루트 엘리먼트, 여러번 사용가능
		<aop:pointcut expression="execution(* com.myspring.biz..*Impl.*(..))" id="allPointcut"/>
		<aop:pointcut expression="execution(* com.myspring.biz..*Impl.get*(..))" id="getPointcut"/>
		                               리턴 타입 | 패키지 경로               | 클래스 명 | 메소드명 및 매개변수 
		<aop:pointcut> : 포인트 컷을 지정하기 위해 사용, 유일한 아이디를 할당하여 aspect 설정할 때 포인트컷 참조 용도로 사용
		<aop:aspect ref="log">
		<aop:before method="printLog" pointcut-ref="getPointcut"/>
		<aop:before method="printLogging" pointcut-ref="allPointcut"/>
		</aop:aspect>
		</aop:config> -->
		<!-- <aop:aspect>와 <aop:advisor> 같은 의미의 용어 : 포인트컷으로 지정한 메소드가 호출될 때, 어드바이스 메소드를 삽입하도록 하는 설정 -->
				<!-- <aop:aspect> : 핵심 관심에 해당하는 포인트컷 메소드와 횡단 관심에 해당하는 어드바이스 메소드를 결합하기 위해 사용 -->
			    <!-- <aop:advisor> : 어드바이스의 메소드 이름을 확인할 수 없을 때 사용 -->
		<!-- 1. getPointcut 포인트컷 메소드 호출  2. log 어드바이스 객체  3. printLog() 메서드 실행  4. 동작시점 : before -->
		
		
		<!-- Before 어드바이스 : 포인트컷으로 지정된 메소드 호출 시, 메소드가 실행되기 전에 처리할 내용들을 기술하기 위해 사용 -->
<!--  		<bean id="before" class="com.myspring.biz.common.BeforeAdvice"></bean>
		<aop:config>
		<aop:pointcut expression="execution(* com.myspring.biz..*Impl.*(..))" id="allPointcut"/>
		<aop:aspect ref="before">
		<aop:before method="beforeLog" pointcut-ref="allPointcut"/>
		</aop:aspect>
		</aop:config>  -->
		
		
		
	    <!-- AfterReturning 어드바이스 : 포인트컷 메소드가 정상적으로 실행되고 나서 생성된 데이터를 리턴하는 시점에 동작, 사후 처리 로직 추가할 때 사용 -->
<!--  		<bean id="afterReturning" class="com.myspring.biz.common.AfterReturningAdvice"></bean>
		<aop:config>
		<aop:pointcut expression="execution(* com.myspring.biz..*Impl.get*(..))" id="getPointcut"/>
		<aop:aspect ref="afterReturning">
		<aop:after-returning method="afterLog" pointcut-ref="getPointcut" returning="returnobj"/>
		비즈니스 메소드가 리턴한 결과값을 returnObj라는 바인드 변수에 바인드하라는 설정 
		</aop:aspect>
		</aop:config> -->
		
		
		
		<!-- AfterReturning 어드바이스 : 포인트컷 메소드가 실행되다가 예외가 발생하는 시점에 동작 -->
		<!--  AfterReturning 어드바이스는 비즈니스 메소드에서 예외가 발생할 때 동작하므로 예외가 발생하지 않을 땐 동작 여부를 확인 할 수 없음,
		따라서 BoardServiceImpl 클래스에 예외 발생 코드 추가 -->
		
		<!-- After 어드바이스 : 예외발생과 무관하게 무조건 실행, try-catch-finally 구문의 finally 블록 -->
	<!-- 	<bean id="afterThrowing" class="com.myspring.biz.common.AfterThrowingAdvice"></bean>
		<bean id="after" class="com.myspring.biz.common.AfterAdvice"></bean>
		<aop:config>
		<aop:pointcut expression="execution(* com.myspring.biz..*Impl.*(..))" id="allPointcut"/>
		<aop:aspect ref="afterThrowing">
		<aop:after-throwing method="exceptionLog" pointcut-ref="allPointcut" throwing="exceptObj" />
		</aop:aspect>
		
		<aop:aspect ref="after">
		<aop:after method="finallyLog" pointcut-ref="allPointcut"/>
		</aop:aspect> 
		</aop:config>   -->
		
		<!-- Around 어드바이스 : 하나의 어드바이스가 비즈니스 메소드 실행 전과 후에 모두 동작 -->
		<!-- Around 어드바이스는 클라이언트의 메소드 호출을 가로채 사전 처리 로직, 사후처리 로직 수행 가능 -->
		<bean id="around" class="com.myspring.biz.common.AroundAdvice"></bean>
		<aop:config>
		<aop:pointcut expression="execution(* com.myspring.biz..*Impl.*(..))" id="allPointcut"/>
		
		<aop:aspect ref="around">
		<aop:around method="aroundLog" pointcut-ref="allPointcut"/>
		</aop:aspect>
		</aop:config> 
		
		
		<!-- <Setter 인젝션 설정 테스트 UserService 컴포넌트> -->
		<!-- UserServiceImpl클래스와  UserDAO  클래스 각각 <bean> 등록-->
		<!-- UserServiceImpl클래스에서 UserDAO 객체를 의존성 주입하기 위한 <property> 설정 추가 -->
<!-- 		<bean id="userService" class="com.myspring.biz.user.impl.UserServiceImpl">
		<property name="userDAO" ref="userDAO"></property>
		</bean>
		
		<bean id="userDAO" class="com.myspring.biz.user.impl.UserDAO"></bean> -->
		
		
		
		

	<!-- 작성한 TV 예제를 스프링 기반으로 테스트하기 위해 스프링 설정 파일에 등록 -->
	<!-- 클래스 하나당 하나의 <bean> 설정이 필요 / class 속성값 : 패키지 경로가 포함된 전체 클래스 경로 지정 -->
	<!-- <bean id="tv" class="polymorphism.SamsungTV"
		init-method="initMethod" destroy-method="destroyMethod"
		lazy-init="true" scope="singleton"> -->

		<!-- <constructor-arg index="0" ref="apple"></constructor-arg> <constructor-arg 
			index="1" value="2700000"></constructor-arg> -->
		<!-- <constructor-arg> 엘리먼트 매개변수의 개수만큼 추가 -->
		<!-- index 속성을 이용해서 호출되는 생성자의 인자(argument) 순서 명확하게 지정가능 -->


		<!-- <setter 인젝션 사용> ==> <property>엘리먼트 사용 -->
		<!-- <property name="speaker" ref="apple"></property>
		<property name="price" value="2700000"></property> -->
		<!-- name속성값 : 호출하고자 하는 메소드 이름 -->
		<!-- 다른 <bean> 객체를 인자로 넘기려면 ref 속성, 기본형 데이터를 넘기려면 value 속성 사용 -->

		<!-- <p네임스페이스 의존성 주입> -->
		<!-- <bean id="tv" class="polymorphism.SamsungTV" p:speaker-ref="sony" 
			p:price="2700000"> -->



	<!-- </bean> -->
	<!-- 실행되는 TV를 LgTV로 변경하면, 클라이언트 소스를 수정하지 않고도 동작하는 TV 변경 가능 -->
	<!-- <bean>객체를 위한 이름을 지정 : id / 정확한 패키지 경로와 클래스 이름 지정 : class(필수적) -->
	<!-- name 속성은 id와 다르게 식별자 작성 규칙을 따르지 않는 문자열도 허용 , id 사용을 선호 -->

	<!-- 서블릿은 init()메소드를 재정의(overriding)하여 멤버변수 초기화 -->
	<!-- init-method 속성 -->
	<!-- init-method : The name of the custom initialization method to invoke 
		after setting bean properties. The method must have no arguments, but may 
		throw any exception. This is an alternative to implementing Spring's InitializingBean 
		interface or marking a method with the PostConstruct annotation. -->
	<!-- 스프링 컨테이너는 <bean> 등록된 클래스 객체를 생성한 후에 init-method 속성으로 지정된 메서드를 호출함, 
		이 메서드에서 멤버 변수에 대한 초기화 작업을 처리함 -->

	<!-- destroy- Method : 스프링 컨테이너가 객체를 삭제하기 직전에 호출될 임의의 메소드 지정 -->

	<!-- lazy-init : (true인 경우) 스프링 컨테이너는 해당 <bean>을 미리 생성하지 않고 클라이언트가 요청하는 
		시점에 생성, 메모리 관리 효율적으로 가능 -->

	<!-- 클래스로부터 객체를 생성하는 쪽에서 자동으로 싱글톤 객체로 생성 -->
	<!-- scope 속성값은 기본이 싱글톤, 해당 bean이 스프링 컨테이너에 의해 단 하나만 생성되어 운용되도록 함 -->
	<!-- prototype : 스프링 컨테이너는 해당 bean이 요청될 때마다 매번 새로운 객체를 생성하여 반환 -->





	<!-- <import resource="context-datasource.xml"></import> datasource 관련 설정 
		<import resource="context-transaction.xml"></import> transaction 관련 설정 -->
	<!-- <import> 태그 : 스프링 기반의 애플리케이션은 단순한 <bean> 등록 외에도 트랜잭션 관리, 예외 처리, 다국어 
		처리 등 복잡하고 다양한 설정이 필요 이런 모든 설정을 하나의 파일로 모두 처리할 수도 있지만 그렇게 하면 스프링 설정 파일이 너무 
		길어지고 관리도 어려움 결국 기능별 여러 XML 파일로 나누어 설정하는 것이 더 효율적 -->
	<!-- 기능별 여러 XML 파일로 나누어 설정하는 것이 효율적 -> 이렇게 분리하여 작성한 설정파일들을 하나로 통합할 떄 <import>사용 
		여러 스프링 설정 파일을 포함함으로써 한 파일에 작성하는 것과 같은 효과 -->


	<!-- <bean id="sony" class="polymorphism.SonySpeaker"></bean> -->
	<!-- 스프링 컨테이너는 기본적으로 bean 등록된 순서대로 객체 생성, 모든 객체는 기본 생성자 호출 원칙 -->
	<!-- 생성자 인젝션으로 의존성 주입된 SonySpeaker가 먼저 객체 생성, 이를 매개변수로 받아들이는 생성자 호출하여 객체 
		생성 -->
	<!-- <bean id="apple" class="polymorphism.AppleSpeaker"></bean> -->


	<!-- <bean id="CollectionBean" class="injection.CollectionBean">
		<property name="addressList"> -->
			<!-- <list> 
			<value>서울시 강남구 역삼동</value> 
			<value>서울시 성동구 행당동</value> 
			</list> -->

			<!-- <set value-type="java.lang.String"> 
			<value>서울시 강남구 역삼동</value> 
			<value>서울시 성동구 성수동</value> 
			<value>서울시 성동구 성수동</value> 
			set 컬렉션은 같은 데이터를 중복해서 저장하지 않는다. 
				</set> -->

			<!-- <map> 
			<entry> 
			<key> <value>고길동</value> </key> 
			<value>서울시 강남구 역삼동</value> 
			</entry> 
			<entry> 
			<key> <value>마이콜</value> </key> 
			<value>서울시 강서구 화곡동</value> 
			</entry> 
			</map> -->

			<!-- <props>
				<prop key="고길동">서울시 강남구 역삼동</prop>
				<prop key="마이콜">서울시 강서구 화곡동</prop>
			</props>
		</property>
	</bean>
 -->

</beans>
